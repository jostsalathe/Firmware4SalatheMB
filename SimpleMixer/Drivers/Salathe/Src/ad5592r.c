/*
 * ad5592r.c
 *
 *  Created on: 15.03.2018
 *      Author: Jost Salathe <jostsalathe@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  version 2 as published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  General Public License for more details.
 */

#include "ad5592r.h"

//variable definitions
SPI_HandleTypeDef *hspiAD5592R;
uint8_t ad5592rChipsActive = 0;
uint32_t ad5592rCsMask[/*4*/] = {SPI6_CS_0_Pin<<16, SPI6_CS_1_Pin<<16, SPI6_CS_2_Pin<<16, SPI6_CS_3_Pin<<16};
uint32_t ad5592rNcsMask[/*4*/] = {SPI6_CS_0_Pin, SPI6_CS_1_Pin, SPI6_CS_2_Pin, SPI6_CS_3_Pin};
__IO uint32_t* ad5592rCsRegs[/*4*/] = {&(SPI6_CS_0_GPIO_Port->BSRR), &(SPI6_CS_1_GPIO_Port->BSRR), &(SPI6_CS_2_GPIO_Port->BSRR), &(SPI6_CS_3_GPIO_Port->BSRR)};
__IO uint16_t* ad5592rSpiDR;
__IO uint32_t* ad5592rSpiSR;

uint16_t ad5592rTRIpins[4] = {0,0,0,0};
uint16_t ad5592rGPIpins[4] = {0,0,0,0};
uint16_t ad5592rGPIpd[4] = {0,0,0,0};
uint16_t ad5592rGPOpins[4] = {0,0,0,0};
uint16_t ad5592rGPOod[4] = {0,0,0,0};
uint16_t ad5592rADCpins[4] = {0,0,0,0};
uint16_t ad5592rDACpins[4] = {0,0,0,0};

uint16_t ad5592rPinValsW[32];
uint16_t ad5592rPinValsR[32];

uint16_t ad5592rSine[AD5592R_N_SINE] = {
		0x800,0x80c,0x819,0x826,0x833,0x840,0x84d,0x85a,
		0x866,0x873,0x880,0x88d,0x89a,0x8a7,0x8b3,0x8c0,
		0x8cd,0x8da,0x8e7,0x8f3,0x900,0x90d,0x91a,0x926,
		0x933,0x940,0x94c,0x959,0x966,0x973,0x97f,0x98c,
		0x998,0x9a5,0x9b2,0x9be,0x9cb,0x9d7,0x9e4,0x9f0,
		0x9fd,0xa09,0xa16,0xa22,0xa2e,0xa3b,0xa47,0xa53,
		0xa60,0xa6c,0xa78,0xa84,0xa91,0xa9d,0xaa9,0xab5,
		0xac1,0xacd,0xad9,0xae5,0xaf1,0xafd,0xb09,0xb15,
		0xb21,0xb2d,0xb38,0xb44,0xb50,0xb5c,0xb67,0xb73,
		0xb7e,0xb8a,0xb96,0xba1,0xbac,0xbb8,0xbc3,0xbcf,
		0xbda,0xbe5,0xbf0,0xbfc,0xc07,0xc12,0xc1d,0xc28,
		0xc33,0xc3e,0xc49,0xc53,0xc5e,0xc69,0xc74,0xc7e,
		0xc89,0xc94,0xc9e,0xca9,0xcb3,0xcbd,0xcc8,0xcd2,
		0xcdc,0xce6,0xcf1,0xcfb,0xd05,0xd0f,0xd19,0xd23,
		0xd2c,0xd36,0xd40,0xd4a,0xd53,0xd5d,0xd66,0xd70,
		0xd79,0xd82,0xd8c,0xd95,0xd9e,0xda7,0xdb0,0xdb9,
		0xdc2,0xdcb,0xdd4,0xddd,0xde6,0xdee,0xdf7,0xdff,
		0xe08,0xe10,0xe19,0xe21,0xe29,0xe31,0xe39,0xe41,
		0xe49,0xe51,0xe59,0xe61,0xe69,0xe70,0xe78,0xe7f,
		0xe87,0xe8e,0xe96,0xe9d,0xea4,0xeab,0xeb2,0xeb9,
		0xec0,0xec7,0xece,0xed5,0xedb,0xee2,0xee8,0xeef,
		0xef5,0xefc,0xf02,0xf08,0xf0e,0xf14,0xf1a,0xf20,
		0xf26,0xf2b,0xf31,0xf37,0xf3c,0xf42,0xf47,0xf4c,
		0xf51,0xf57,0xf5c,0xf61,0xf66,0xf6a,0xf6f,0xf74,
		0xf79,0xf7d,0xf82,0xf86,0xf8a,0xf8f,0xf93,0xf97,
		0xf9b,0xf9f,0xfa3,0xfa6,0xfaa,0xfae,0xfb1,0xfb5,
		0xfb8,0xfbb,0xfbf,0xfc2,0xfc5,0xfc8,0xfcb,0xfce,
		0xfd0,0xfd3,0xfd6,0xfd8,0xfdb,0xfdd,0xfdf,0xfe2,
		0xfe4,0xfe6,0xfe8,0xfea,0xfeb,0xfed,0xfef,0xff0,
		0xff2,0xff3,0xff5,0xff6,0xff7,0xff8,0xff9,0xffa,
		0xffb,0xffc,0xffc,0xffd,0xffe,0xffe,0xffe,0xfff,
		0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xffe,0xffe,
		0xffe,0xffd,0xffc,0xffc,0xffb,0xffa,0xff9,0xff8,
		0xff7,0xff6,0xff5,0xff3,0xff2,0xff0,0xfef,0xfed,
		0xfeb,0xfea,0xfe8,0xfe6,0xfe4,0xfe2,0xfdf,0xfdd,
		0xfdb,0xfd8,0xfd6,0xfd3,0xfd0,0xfce,0xfcb,0xfc8,
		0xfc5,0xfc2,0xfbf,0xfbb,0xfb8,0xfb5,0xfb1,0xfae,
		0xfaa,0xfa6,0xfa3,0xf9f,0xf9b,0xf97,0xf93,0xf8f,
		0xf8a,0xf86,0xf82,0xf7d,0xf79,0xf74,0xf6f,0xf6a,
		0xf66,0xf61,0xf5c,0xf57,0xf51,0xf4c,0xf47,0xf42,
		0xf3c,0xf37,0xf31,0xf2b,0xf26,0xf20,0xf1a,0xf14,
		0xf0e,0xf08,0xf02,0xefc,0xef5,0xeef,0xee8,0xee2,
		0xedb,0xed5,0xece,0xec7,0xec0,0xeb9,0xeb2,0xeab,
		0xea4,0xe9d,0xe96,0xe8e,0xe87,0xe7f,0xe78,0xe70,
		0xe69,0xe61,0xe59,0xe51,0xe49,0xe41,0xe39,0xe31,
		0xe29,0xe21,0xe19,0xe10,0xe08,0xdff,0xdf7,0xdee,
		0xde6,0xddd,0xdd4,0xdcb,0xdc2,0xdb9,0xdb0,0xda7,
		0xd9e,0xd95,0xd8c,0xd82,0xd79,0xd70,0xd66,0xd5d,
		0xd53,0xd4a,0xd40,0xd36,0xd2c,0xd23,0xd19,0xd0f,
		0xd05,0xcfb,0xcf1,0xce6,0xcdc,0xcd2,0xcc8,0xcbd,
		0xcb3,0xca9,0xc9e,0xc94,0xc89,0xc7e,0xc74,0xc69,
		0xc5e,0xc53,0xc49,0xc3e,0xc33,0xc28,0xc1d,0xc12,
		0xc07,0xbfc,0xbf0,0xbe5,0xbda,0xbcf,0xbc3,0xbb8,
		0xbac,0xba1,0xb96,0xb8a,0xb7e,0xb73,0xb67,0xb5c,
		0xb50,0xb44,0xb38,0xb2d,0xb21,0xb15,0xb09,0xafd,
		0xaf1,0xae5,0xad9,0xacd,0xac1,0xab5,0xaa9,0xa9d,
		0xa91,0xa84,0xa78,0xa6c,0xa60,0xa53,0xa47,0xa3b,
		0xa2e,0xa22,0xa16,0xa09,0x9fd,0x9f0,0x9e4,0x9d7,
		0x9cb,0x9be,0x9b2,0x9a5,0x998,0x98c,0x97f,0x973,
		0x966,0x959,0x94c,0x940,0x933,0x926,0x91a,0x90d,
		0x900,0x8f3,0x8e7,0x8da,0x8cd,0x8c0,0x8b3,0x8a7,
		0x89a,0x88d,0x880,0x873,0x866,0x85a,0x84d,0x840,
		0x833,0x826,0x819,0x80c,0x800,0x7f3,0x7e6,0x7d9,
		0x7cc,0x7bf,0x7b2,0x7a5,0x799,0x78c,0x77f,0x772,
		0x765,0x758,0x74c,0x73f,0x732,0x725,0x718,0x70c,
		0x6ff,0x6f2,0x6e5,0x6d9,0x6cc,0x6bf,0x6b3,0x6a6,
		0x699,0x68c,0x680,0x673,0x667,0x65a,0x64d,0x641,
		0x634,0x628,0x61b,0x60f,0x602,0x5f6,0x5e9,0x5dd,
		0x5d1,0x5c4,0x5b8,0x5ac,0x59f,0x593,0x587,0x57b,
		0x56e,0x562,0x556,0x54a,0x53e,0x532,0x526,0x51a,
		0x50e,0x502,0x4f6,0x4ea,0x4de,0x4d2,0x4c7,0x4bb,
		0x4af,0x4a3,0x498,0x48c,0x481,0x475,0x469,0x45e,
		0x453,0x447,0x43c,0x430,0x425,0x41a,0x40f,0x403,
		0x3f8,0x3ed,0x3e2,0x3d7,0x3cc,0x3c1,0x3b6,0x3ac,
		0x3a1,0x396,0x38b,0x381,0x376,0x36b,0x361,0x356,
		0x34c,0x342,0x337,0x32d,0x323,0x319,0x30e,0x304,
		0x2fa,0x2f0,0x2e6,0x2dc,0x2d3,0x2c9,0x2bf,0x2b5,
		0x2ac,0x2a2,0x299,0x28f,0x286,0x27d,0x273,0x26a,
		0x261,0x258,0x24f,0x246,0x23d,0x234,0x22b,0x222,
		0x219,0x211,0x208,0x200,0x1f7,0x1ef,0x1e6,0x1de,
		0x1d6,0x1ce,0x1c6,0x1be,0x1b6,0x1ae,0x1a6,0x19e,
		0x196,0x18f,0x187,0x180,0x178,0x171,0x169,0x162,
		0x15b,0x154,0x14d,0x146,0x13f,0x138,0x131,0x12a,
		0x124,0x11d,0x117,0x110,0x10a,0x103,0xfd,0xf7,
		0xf1,0xeb,0xe5,0xdf,0xd9,0xd4,0xce,0xc8,
		0xc3,0xbd,0xb8,0xb3,0xae,0xa8,0xa3,0x9e,
		0x99,0x95,0x90,0x8b,0x86,0x82,0x7d,0x79,
		0x75,0x70,0x6c,0x68,0x64,0x60,0x5c,0x59,
		0x55,0x51,0x4e,0x4a,0x47,0x44,0x40,0x3d,
		0x3a,0x37,0x34,0x31,0x2f,0x2c,0x29,0x27,
		0x24,0x22,0x20,0x1d,0x1b,0x19,0x17,0x15,
		0x14,0x12,0x10,0xf,0xd,0xc,0xa,0x9,
		0x8,0x7,0x6,0x5,0x4,0x3,0x3,0x2,
		0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,
		0x0,0x0,0x1,0x1,0x1,0x2,0x3,0x3,
		0x4,0x5,0x6,0x7,0x8,0x9,0xa,0xc,
		0xd,0xf,0x10,0x12,0x14,0x15,0x17,0x19,
		0x1b,0x1d,0x20,0x22,0x24,0x27,0x29,0x2c,
		0x2f,0x31,0x34,0x37,0x3a,0x3d,0x40,0x44,
		0x47,0x4a,0x4e,0x51,0x55,0x59,0x5c,0x60,
		0x64,0x68,0x6c,0x70,0x75,0x79,0x7d,0x82,
		0x86,0x8b,0x90,0x95,0x99,0x9e,0xa3,0xa8,
		0xae,0xb3,0xb8,0xbd,0xc3,0xc8,0xce,0xd4,
		0xd9,0xdf,0xe5,0xeb,0xf1,0xf7,0xfd,0x103,
		0x10a,0x110,0x117,0x11d,0x124,0x12a,0x131,0x138,
		0x13f,0x146,0x14d,0x154,0x15b,0x162,0x169,0x171,
		0x178,0x180,0x187,0x18f,0x196,0x19e,0x1a6,0x1ae,
		0x1b6,0x1be,0x1c6,0x1ce,0x1d6,0x1de,0x1e6,0x1ef,
		0x1f7,0x200,0x208,0x211,0x219,0x222,0x22b,0x234,
		0x23d,0x246,0x24f,0x258,0x261,0x26a,0x273,0x27d,
		0x286,0x28f,0x299,0x2a2,0x2ac,0x2b5,0x2bf,0x2c9,
		0x2d3,0x2dc,0x2e6,0x2f0,0x2fa,0x304,0x30e,0x319,
		0x323,0x32d,0x337,0x342,0x34c,0x356,0x361,0x36b,
		0x376,0x381,0x38b,0x396,0x3a1,0x3ac,0x3b6,0x3c1,
		0x3cc,0x3d7,0x3e2,0x3ed,0x3f8,0x403,0x40f,0x41a,
		0x425,0x430,0x43c,0x447,0x453,0x45e,0x469,0x475,
		0x481,0x48c,0x498,0x4a3,0x4af,0x4bb,0x4c7,0x4d2,
		0x4de,0x4ea,0x4f6,0x502,0x50e,0x51a,0x526,0x532,
		0x53e,0x54a,0x556,0x562,0x56e,0x57b,0x587,0x593,
		0x59f,0x5ac,0x5b8,0x5c4,0x5d1,0x5dd,0x5e9,0x5f6,
		0x602,0x60f,0x61b,0x628,0x634,0x641,0x64d,0x65a,
		0x667,0x673,0x680,0x68c,0x699,0x6a6,0x6b3,0x6bf,
		0x6cc,0x6d9,0x6e5,0x6f2,0x6ff,0x70c,0x718,0x725,
		0x732,0x73f,0x74c,0x758,0x765,0x772,0x77f,0x78c,
		0x799,0x7a5,0x7b2,0x7bf,0x7cc,0x7d9,0x7e6,0x7f3
};

//functions
uint8_t ad5592rSetup(SPI_HandleTypeDef *hspi, uint8_t activeChips) {
	int i;
	ad5592rChipsActive = activeChips & 0xF;
	hspiAD5592R = hspi;
	ad5592rSpiDR = (uint16_t *) &(hspi->Instance->DR);
	ad5592rSpiSR = &(hspi->Instance->SR);
	for (i=0; i<4; ++i) {
		AD5592R_DESELECT(i);
	}
	__HAL_SPI_ENABLE(hspi);
	//flush the SPI RXFIFO
	AD5592R_SPI_READ(ad5592rPinValsR[0]);
	AD5592R_SPI_READ(ad5592rPinValsR[0]);
	//check if all AD5592Rs respond correctly
	for (i=0; i<4; ++i) {
		if (AD5592R_CHIP_ACTIVE(i)) {
			ad5592rReg_t reg;
			reg.cmd.DnC = AD5592R_SEND_CMD;
			reg.cmd.addr = AD5592R_REG_GPI_PINS;
			reg.cmd.data = 0xFF;
			ad5592rTxRxReg(i, reg);
			reg.cmd.addr = AD5592R_REG_RDBK_LDAC;
			reg.cmd.data = AD5592r_RDBK_REG(AD5592R_REG_GPI_PINS);
			ad5592rTxRxReg(i, reg);
			reg = ad5592rTxRxReg(i, (ad5592rReg_t) {0});
			if (reg.cmd.data != 0xFF) {
				ad5592rChipsActive &= ~(1<<i); //deactivate chip i
			}
		}
	}
	//write initial pin configuration
	for (i=0; i<32; ++i) {
		ad5592rPinValsW[i] = 0;
		ad5592rPinValsR[i] = 0;
		ad5592rSetPinMode((ad5592rPin_t) (uint8_t) i, ad5592rDigitalInPullDown);
	}
	ad5592rUpdatePinModes();
	return ad5592rChipsActive;
}

void ad5592rSetPinMode(ad5592rPin_t pin, ad5592rPinMode_t mode) {
	int pinmask = 1<<pin.pin;
	int chip =  pin.chip;
	if (!AD5592R_CHIP_ACTIVE(chip)) return;
	switch(mode) {
	case ad5592rThreeState: {
		//activate TRI function
		ad5592rTRIpins[chip] |= pinmask;
		//deactivate other functions
		ad5592rGPIpins[chip] &= ~pinmask;
		ad5592rGPIpd[chip] &= ~pinmask;
		ad5592rGPOpins[chip] &= ~pinmask;
		ad5592rGPOod[chip] &= ~pinmask;
		ad5592rADCpins[chip] &= ~pinmask;
		ad5592rDACpins[chip] &= ~pinmask;
		break;}
	case ad5592rDigitalIn: {
		//activate GPI function
		ad5592rGPIpins[chip] |= pinmask;
		//deactivate other functions
		ad5592rTRIpins[chip] &= ~pinmask;
		ad5592rGPIpd[chip] &= ~pinmask;
		ad5592rGPOpins[chip] &= ~pinmask;
		ad5592rGPOod[chip] &= ~pinmask;
		ad5592rADCpins[chip] &= ~pinmask;
		ad5592rDACpins[chip] &= ~pinmask;
		break;}
	case ad5592rDigitalInPullDown: {
		//activate GPI function
		ad5592rGPIpins[chip] |= pinmask;
		ad5592rGPIpd[chip] |= pinmask;
		//deactivate other functions
		ad5592rTRIpins[chip] &= ~pinmask;
		ad5592rGPOpins[chip] &= ~pinmask;
		ad5592rGPOod[chip] &= ~pinmask;
		ad5592rADCpins[chip] &= ~pinmask;
		ad5592rDACpins[chip] &= ~pinmask;
		break;}
	case ad5592rDigitalOut: {
		//activate GPO function
		ad5592rGPOpins[chip] |= pinmask;
		ad5592rGPIpins[chip] |= pinmask;
		//deactivate other functions
		ad5592rTRIpins[chip] &= ~pinmask;
		ad5592rGPIpd[chip] &= ~pinmask;
		ad5592rGPOod[chip] &= ~pinmask;
		ad5592rADCpins[chip] &= ~pinmask;
		ad5592rDACpins[chip] &= ~pinmask;
		break;}
	case ad5592rDigitalOutOpenDrain: {
		//activate GPO function
		ad5592rGPIpins[chip] |= pinmask;
		ad5592rGPOpins[chip] |= pinmask;
		ad5592rGPOod[chip] |= pinmask;
		//deactivate other functions
		ad5592rTRIpins[chip] &= ~pinmask;
		ad5592rGPIpd[chip] &= ~pinmask;
		ad5592rADCpins[chip] &= ~pinmask;
		ad5592rDACpins[chip] &= ~pinmask;
		break;}
	case ad5592rAnalogIn: {
		//activate ADC function
		ad5592rADCpins[chip] |= pinmask;
		//deactivate other functions
		ad5592rTRIpins[chip] &= ~pinmask;
		ad5592rGPIpins[chip] &= ~pinmask;
		ad5592rGPIpd[chip] &= ~pinmask;
		ad5592rGPOpins[chip] &= ~pinmask;
		ad5592rGPOod[chip] &= ~pinmask;
		ad5592rDACpins[chip] &= ~pinmask;
		break;}
	case ad5592rAnalogOut: {
		//activate DAC function
		ad5592rDACpins[chip] |= pinmask;
		//deactivate other functions
		ad5592rTRIpins[chip] &= ~pinmask;
		ad5592rGPIpins[chip] &= ~pinmask;
		ad5592rGPIpd[chip] &= ~pinmask;
		ad5592rGPOpins[chip] &= ~pinmask;
		ad5592rGPOod[chip] &= ~pinmask;
		ad5592rADCpins[chip] &= ~pinmask;
		break;}
	case ad5592rAnalogInOut: {
		//activate ADC and DAC function
		ad5592rDACpins[chip] |= pinmask;
		ad5592rADCpins[chip] |= pinmask;
		//deactivate other functions
		ad5592rTRIpins[chip] &= ~pinmask;
		ad5592rGPIpins[chip] &= ~pinmask;
		ad5592rGPIpd[chip] &= ~pinmask;
		ad5592rGPOpins[chip] &= ~pinmask;
		ad5592rGPOod[chip] &= ~pinmask;
		break;}
	default: return;
	}
}

void ad5592rUpdatePinModes() {
	//for detecting changes and only transmitting those
	static uint16_t lastAd5592rTRIpins[4] = {1,1,1,1};
	static uint16_t lastAd5592rGPIpins[4] = {1,1,1,1};
	static uint16_t lastAd5592rGPIpd[4] = {1,1,1,1};
	static uint16_t lastAd5592rGPOpins[4] = {1,1,1,1};
	static uint16_t lastAd5592rGPOod[4] = {1,1,1,1};
	static uint16_t lastAd5592rADCpins[4] = {1,1,1,1};
	static uint16_t lastAd5592rDACpins[4] = {1,1,1,1};
	int chip;
	ad5592rReg_t msg;
	msg.cmd.DnC = AD5592R_SEND_CMD;
	for (chip=0; chip<4; ++chip){
		if (AD5592R_CHIP_ACTIVE(chip)) {
			if (lastAd5592rTRIpins[chip] != ad5592rTRIpins[chip]) {
				msg.cmd.addr = AD5592R_REG_GPO_TRI;
				msg.cmd.data = ad5592rTRIpins[chip];
				lastAd5592rTRIpins[chip] = ad5592rTRIpins[chip];
				ad5592rTxRxReg(chip, msg);
			}
			if (lastAd5592rGPIpins[chip] != ad5592rGPIpins[chip]) {
				msg.cmd.addr = AD5592R_REG_GPI_PINS;
				msg.cmd.data = ad5592rGPIpins[chip];
				lastAd5592rGPIpins[chip] = ad5592rGPIpins[chip];
				ad5592rTxRxReg(chip, msg);
			}
			if (lastAd5592rGPIpd[chip] != ad5592rGPIpd[chip]) {
				msg.cmd.addr = AD5592R_REG_PULL_DOWN;
				msg.cmd.data = ad5592rGPIpd[chip];
				lastAd5592rGPIpd[chip] = ad5592rGPIpd[chip];
				ad5592rTxRxReg(chip, msg);
			}
			if (lastAd5592rGPOpins[chip] != ad5592rGPOpins[chip]) {
				msg.cmd.addr = AD5592R_REG_GPO_PINS;
				msg.cmd.data = ad5592rGPOpins[chip];
				lastAd5592rGPOpins[chip] = ad5592rGPOpins[chip];
				ad5592rTxRxReg(chip, msg);
			}
			if (lastAd5592rGPOod[chip] != ad5592rGPOod[chip]) {
				msg.cmd.addr = AD5592R_REG_GPO_OD;
				msg.cmd.data = ad5592rGPOod[chip];
				lastAd5592rGPOod[chip] = ad5592rGPOod[chip];
				ad5592rTxRxReg(chip, msg);
			}
			if (lastAd5592rADCpins[chip] != ad5592rADCpins[chip]) {
				msg.cmd.addr = AD5592R_REG_ADC_PINS;
				msg.cmd.data = ad5592rADCpins[chip];
				lastAd5592rADCpins[chip] = ad5592rADCpins[chip];
				ad5592rTxRxReg(chip, msg);
			}
			if (lastAd5592rDACpins[chip] != ad5592rDACpins[chip]) {
				msg.cmd.addr = AD5592R_REG_DAC_PINS;
				msg.cmd.data = ad5592rDACpins[chip];
				lastAd5592rDACpins[chip] = ad5592rDACpins[chip];
				ad5592rTxRxReg(chip, msg);
			}
		}
	}
}

void ad5592rSetPin(ad5592rPin_t pin, uint16_t val){
	ad5592rPinValsW[pin.number%32] = val;
}

uint16_t ad5592rGetPin(ad5592rPin_t pin){
	return ad5592rPinValsR[pin.number%32];
}

void ad5592rUpdate(){
	int chip, pin, iAdc, nAdc;
	ad5592rReg_t cmdMsg, dacMsg;
	cmdMsg.cmd.DnC = AD5592R_SEND_CMD;
	//treat one chip at a time
	for (chip=0; chip<4; ++chip) {
		if (AD5592R_CHIP_ACTIVE(chip)) {
			uint16_t pinVals[8];
			//save the set values locally
			for (pin=0; pin<8; ++pin) {
				pinVals[pin] = ad5592rPinValsW[chip*8+pin];
			}
			//handle digital pins
			if (ad5592rGPIpins[chip]) {
				cmdMsg.cmd.addr = AD5592R_REG_GPI_PINS;
				cmdMsg.cmd.data = AD5592R_RDBK_GPI | ad5592rGPIpins[chip];
				//send GPI readback command
				AD5592R_SELECT(chip);
				AD5592R_SPI_WRITE(cmdMsg.reg);
				//prepare digital output data or nop
				if (ad5592rGPOpins[chip]) {
					cmdMsg.cmd.addr = AD5592R_REG_GPO_WRITE;
					cmdMsg.cmd.data = 0;
					for (pin=0; pin<8; ++pin) {
						if (((ad5592rGPOpins[chip]>>pin)&1)
								&& pinVals[pin]) {
							cmdMsg.cmd.data |= 1<<pin;
						}
					}
				} else {
					cmdMsg.reg = 0; //nop
				}
				//wait for transmission complete
				while (AD5592R_SPI_BUSY) vTaskDelay(0);
				AD5592R_DESELECT(chip);
				AD5592R_SPI_READ(dacMsg.reg);

				//send prepared command (digital output data or nop) and receive digital input data
				cmdMsg = ad5592rTxRxReg(chip, cmdMsg);

				for (pin=0; pin<8; ++pin) {
					if (ad5592rGPIpins[chip] & 1<<pin) {
						ad5592rPinValsR[chip*8+pin] = (cmdMsg.reg>>pin)&1;
					}
				}
			}

			//handle analog pins if configured (always temperature)
			iAdc = 0;
			nAdc = 0;
			//count number of active ADCs
			if (ad5592rADCpins[chip]) {
				for (pin=0; pin<8; ++pin) {
					if ((ad5592rADCpins[chip]>>pin)&1) {
						++nAdc;
					}
				}
				//initiate ADC conversion sequence if necessary
				if (nAdc) {
					cmdMsg.cmd.addr = AD5592R_REG_ADC_SEQ;
					cmdMsg.cmd.data = ad5592rADCpins[chip];
					cmdMsg = ad5592rTxRxReg(chip, cmdMsg);
					iAdc = -1; //for reading rubbish data once
				}
			}

			//send DAC values
			if (ad5592rDACpins[chip]) {
				dacMsg.dacWrite.DnC = AD5592R_SEND_DATA;
				for (pin=0; pin<8; ++pin) {
					if ((ad5592rDACpins[chip]>>pin)&1) {
						//send dac value
						dacMsg.dacWrite.addr = pin;
						dacMsg.dacWrite.data = pinVals[pin];
						cmdMsg = ad5592rTxRxReg(chip, dacMsg);

						//treat received data
						if (iAdc<nAdc && iAdc>=0) { //to skip first rx after starting ADC sequence
							ad5592rPinValsR[chip*8+cmdMsg.dacWrite.addr] = cmdMsg.dacWrite.data;
						}
						++iAdc;
					}
				}
			}
			dacMsg.reg = 0;
			while (iAdc<nAdc) {
				//receive data via nop
				cmdMsg = ad5592rTxRxReg(chip, dacMsg);
				//treat received data
				if (iAdc>=0) { //to skip first rx after starting ADC sequence
					ad5592rPinValsR[chip*8+cmdMsg.dacWrite.addr] = cmdMsg.dacWrite.data;
				}
				++iAdc;
			}
		}
	}
}

ad5592rReg_t ad5592rTxRxReg(uint8_t chip, ad5592rReg_t reg) {
	if (!AD5592R_CHIP_ACTIVE(chip)) {
		reg.reg = 0;
		return reg;
	}
	AD5592R_SELECT(chip);
	AD5592R_SPI_WRITE(reg.reg);
	while (AD5592R_SPI_BUSY) vTaskDelay(0);
	AD5592R_DESELECT(chip);
	AD5592R_SPI_READ(reg.reg);
	return reg;
}
